.. _cpp_err_handling:

Error Handling in C++
---------------------

In multiple places in our codebase, we call C++ functions from Python.
This brings about the challenge of error handling i.e. of communicating any errors that happen in C++ back to Python.

Raising errors in C++ is not sufficient because:
(i) your Python code may not be made aware of it, and
(ii) errors raised in C++ might not be visible to Notebook users.
Hence it is important that these are communicated back to and raised in Python.

In particular, we want to do this:
(i) as soon as possible, and 
(ii) with the right error message.
To achieve this goal, we use the following approach:

- Whenever we encounter an error in our C++ code, we throw an Exception (:code:`std::runtime_error`, etc.) on all processes (this might require special handling in cases where the code is being run on only process 0 and other similar cases). 
  We do this to ensure that we exit the C++ code and return to Python as soon as possible (since we do not want to continue execution as that might lead to crashes, etc.) and raise the right error there. 
- In all the C++ functions that are called directly from Python, we use a :code:`try-except` clause to catch exceptions encountered during the C++ execution. 
- After catching these exceptions, we use the Python/C API's :code:`PyErr_SetString` function to set the error string (which is accessible to both Python and C++) to the error message of the caught exception, and return back to Python (either with an invalid value like -1 or NULL).
    NOTE: Using :code:`PyErr_SetString` also sets the error indicator, which we can then check to see if an error occured during C++ code execution.
- When we return back to Python from C++, we call the intrinsic `check_and_propagate_cpp_exception() <https://github.com/Bodo-inc/Bodo/blob/3c46441a2b120dcc496ed09613e1e58593e15101/bodo/utils/utils.py#L953>`_ defined in `bodo.utils.utils <https://github.com/Bodo-inc/Bodo/blob/master/bodo/utils/utils.py>`_. 
  This function first checks if an error occurred, and if one did, it raises the error that was set using :code:`PyErr_SetString`, in Python (which is the desired behavior).

C++ Error Handling Template
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Here's a short template for implementing the above approach:

Say we have a Python function :code:`python_func` that calls a C++ function :code:`cpp_func` (through an IR extension/llvm symbol, etc.).
We would (re-)write :code:`cpp_func` as follows:

.. code-block:: cpp

  int cpp_func(...) {  // C++ function called directly from Python
    try {
        // ...
        if (error_occured)
            throw std::runtime_error(err_msg);
        // ...
    } catch (const std::exception &e) {  // catch any and all exceptions
        PyErr_SetString(PyExc_RuntimeError, e.what());
        return -1;  // return some invalid value
    }
  }

The exception may not be thrown by the top-level function (:code:`cpp_func`) directly, but by another function called recursively during the execution of :code:`cpp_func`.

Similarly in the Python function :code:`python_func`, we would make the following change:

.. code-block:: python

  def python_func(...):
    # ...
    # Call the C++ function
    cpp_func_result = cpp_func(...)
    # Check if there was an error in the C++ code. If so, raise it.
    bodo.utils.utils.check_and_propagate_cpp_exception()
    # ...


Existing Concrete Example
~~~~~~~~~~~~~~~~~~~~~~~~~

We've implemented this C++ error handling approach in several places in our code.
Here's a small example:

The :code:`csv_reader_py` (function used for :code:`pd.read_csv`) function generated by :code:`_gen_csv_reader_py` in :code:`csv_ext.py` calls the function :code:`bodo.ir.csv_ext.csv_file_chunk_reader` which is a C++ function defined in :code:`_csv_json_reader.cpp`. 
The function :code:`csv_file_chunk_reader` is just a wrapper around the function :code:`file_chunk_reader`. This function is therefore a entry point into C++ from Python. 
We've put a :code:`try-catch` block around the whole function to catch any exceptions that occur during the execution of this function. For instance, this function calls the function :code:`read_uncompressed_file` (defined in the same file). 
This function makes use of the :code:`CHECK_ARROW` macro, which checks the status of an operation in :code:`Arrow` (in this case :code:`OpenOutputFile`), raising an error with an appropriate error message if the status is not ok, else, allowing the call to :code:`ValueOrDie()` (which crashes if the status isn't ok, hence the need for the check).
Now, at runtime, if there was indeed an error in this call (:code:`OpenOutputFile`), the macro :code:`CHECK_ARROW` would notice it and raise a :code:`std::runtime_error` with the right error message. This error would be caught by the top-level :code:`file_chunk_reader` function since it has a :code:`try-catch` block as mentioned before.
Once caught, we use :code:`PyErr_SetString` to set the error type to a Python Runtime Error and the error message to the error message in the caught C++ exception.
Now, when we return to Python (in the :code:`csv_reader_py` function) from C++, we call the function :code:`check_and_propagate_cpp_exception` straight away. 
The function :code:`check_and_propagate_cpp_exception` notices that an error was raised in C++, and hence it raises the error set via :code:`PyErr_SetString`, in Python, successfully detecting the error and informing the user of it.


Useful references:
~~~~~~~~~~~~~~~~~~

- `Python/C API Exception Handling Guide <https://docs.python.org/3/c-api/exceptions.html>`_
    In particular, see `PyErr_SetString <https://docs.python.org/3/c-api/exceptions.html#c.PyErr_SetString>`_ and `PyErr_Occurred <https://docs.python.org/3/c-api/exceptions.html#c.PyErr_Occurred>`_.
- `Numba Guide to @intrinsic <https://numba.readthedocs.io/en/stable/extending/high-level.html#implementing-intrinsics>`_
- `Numba PythonAPI Error Handling <https://github.com/numba/numba/blob/master/numba/core/pythonapi.py#L278>`_
- `Numba Calling Convention <https://github.com/numba/numba/blob/master/numba/core/callconv.py#L42>`_
