.. _bodosql:

Bodo SQL
========

Bodo SQL provides seamless integration of pandas programs with SQL queries on structured data. You can use it to either
port your existing SQL code to pandas programs, or write pandas programs including SQL queries passed to the Bodo SQL context.
The result of executing SQL code with Bodo SQL is returned as a DataFrame. BodoSQL is currently in alpha, and currently supports a basic
workable subset of SQL detailed below.


Bodo SQL context
----------------

Bodo SQL offers an entry point for SQL queries into pandas through Bodo SQL context.
DataFrames are created and accessed from pandas code through Bodo SQL context as below::


    import bodosql
    import pytest

    df1 = pd.DataFrame(
        {"A": [1, 3, 2, 1], "B": [2.2, 1.2, 4.4, 2.3], "C": [5, 2, 1, 4]}
    )
    df2 = pd.DataFrame({"A": [4, 1, 2], "D": [5.1, 5.2, 2.3]})
    test_df2['DateCol']  = pd.to_datetime(test_df2['DateCol'])
    bc = bodosql.BodoSQLContext({"table1": df1, "table2": df2})

SQL queries can then be passed to the Bodo SQL context::

    query = "select A from table1"
    df1 = bc.sql(query)
    print(df1)

Bodo SQL automatically translates this query into its corresponding pandas code::

  df1 = table1[['A',]]

which returns a dataframe::

       A
    0  1
    1  3
    2  2
    3  1

Bodo SQL translates queries into step-by-step pandas code, creating intermediate dataframes when necessary.
For instance, the pandas code generated by Bodo SQL from the SQL query ``select sum(A) as mySum from table1 where A>1`` is as follows::

  df1 = table1[(table1["A"] > 1)]
  df2 = pd.DataFrame({"A": df1["A"], })
  df3 = pd.DataFrame({"mySum": [df2["A"].sum()],})

With output::

   0
0  5

As we can see, first it extracts the rows of ``table1`` where ``table1[A] > 1``.
Then it creates a dataframe with just those rows. Finally, it computes the sum of the column and renames the column to ``mySum``.




Supported Operations
--------------------
We currently support the following SQL query statements and clauses with Bodo SQL, and are continuously adding support towards completeness. Note that
currently, Bodo SQL ignores casing of keywords, and column and table names. So, ``select a from table1`` is treated the same as ``SELECT A FROM TABLE1``.

* `SELECT`

    The ``SELECT`` statement is used to select data in the form of columns. The data returned from Bodo SQL is stored in a DataFrame. Example usage::

        SELECT <COLUMN_NAMES> FROM <TABLE_NAME>

    The ``SELECT DISTINCT`` statement is used to return only distinct (different) values::

        SELECT DISTINCT <COLUMN_NAMES> FROM <TABLE_NAME>

* `WHERE`

    The ``WHERE`` clause on columns can be used to filter records that satisfy specific conditions::

        SELECT <COLUMN_NAMES> FROM <TABLE_NAME> WHERE <CONDITION>

    Note that the ``WHERE`` clause can also be used in ``UPDATE`` and ``DELETE`` statements, which we will support in a future release.

* `ORDER BY`

    The ``ORDER BY`` keyword sorts the resulting DataFrame in ascending or descending order. By default, it sorts the records in ascending order.
    For descending order, we use the ``DESC`` keyword::

        SELECT <COLUMN_NAMES>
        FROM <TABLE_NAME>
        ORDER BY <ORDERED_COLUMN_NAMES> ASC|DESC


* Null Values

    We can check for null values using the ``IS_NULL`` and ``IS_NOT_NULL`` keywords::

        SELECT <COLUMN_NAMES>
        FROM <TABLE_NAME>
        WHERE <COLUMN_NAME> IS NULL


        SELECT <COLUMN_NAMES>
        FROM <TABLE_NAME>
        WHERE <COLUMN_NAME> IS NOT NULL


* `LIMIT`

    Bodo SQL supports the ``LIMIT`` keyword to select a limited number of rows::

        SELECT <COLUMN_NAMES>
        FROM <TABLE_NAME>
        WHERE <CONDITION>
        LIMIT <NUMBER>


* Aggregation Functions

  - The ``MIN()``, and ``MAX()`` functions return the smallest and the largest value of the selected column respectively::

        SELECT MIN(<COLUMN_NAME>)
        FROM <TABLE_NAME>
        WHERE <CONDITION>;

        SELECT MAX(<COLUMN_NAME>)
        FROM <TABLE_NAME>
        WHERE <CONDITION>;

  - The ``COUNT()`` function can be used to count the number of rows that match a condition::

        SELECT COUNT(<COLUMN_NAME>)
        FROM <TABLE_NAME>
        WHERE <CONDITION>;

  - The ``SUM()`` function returns the total sum of a column with numeric values::

        SELECT SUM(<COLUMN_NAME>)
        FROM <TABLE_NAME>
        WHERE <CONDITION>;

  - The AVG() function returns the average value of a numeric column::

        SELECT AVG(<COLUMN_NAME>)
        FROM <TABLE_NAME>
        WHERE <CONDITION>;


* `IN`

    The ``IN`` keyword is used to pick specific values of a column in a ``WHERE`` clause::

        SELECT <COLUMN_NAMES>
        FROM <TABLE_NAME>
        WHERE <COLUMN_NAME> IN <VALUES>;


        SELECT <COLUMN_NAMES>
        FROM <TABLE_NAME>
        WHERE <COLUMN_NAME> IN (SELECT STATEMENT);


* `BETWEEN`

    The ``BETWEEN`` operator selects values within a given range. The values can be numbers, text, or dates.
    The ``BETWEEN`` operator is inclusive: begin and end values are included::

        SELECT <COLUMN_NAMES>
        FROM <TABLE_NAME>
        WHERE <COLUMN_NAME> BETWEEN <VALUE1> AND <VALUE2>;


* `JOIN`

    A ``JOIN`` clause is used to combine rows from two or more tables, based on a related column between them::

      SELECT <COLUMN_NAMES>
        FROM <LEFT_TABLE_NAME>
        <JOIN_TYPE> <RIGHT_TABLE_NAME>
        ON <LEFT_TABLE_COLUMN_NAME = <RIGHT_TABLE_COLUMN_NAME>;

    Here are the different types of the ``JOINs`` in SQL:

    - ``(INNER) JOIN``: Returns records that have matching values in both tables
    - ``LEFT (OUTER) JOIN``: Returns all records from the left table, and the matched records from the right table
    - ``RIGHT (OUTER) JOIN``: Returns all records from the right table, and the matched records from the left table
    - ``FULL (OUTER) JOIN``: Returns all records when there is a match in either left or right table


* `UNION`
    The ``UNION`` operator is used to combine the result-set of two or more ``SELECT`` statements::

        SELECT <COLUMN_NAMES> FROM <TABLE1>
        UNION
        SELECT <COLUMN_NAMES> FROM <TABLE2>;

    Each ``SELECT`` statement within ``UNION`` must have the same number of columns.
    The columns must also have similar data types, and columns in each ``SELECT`` statement must also be in the same order.


    The ``UNION`` operator selects only distinct values by default. To allow duplicate values, use ``UNION ALL``::

        SELECT <COLUMN_NAMES> FROM <TABLE1>
        UNION ALL
        SELECT <COLUMN_NAMES> FROM <TABLE2>;


* `GROUP BY`
    The ``GROUP BY`` statement groups rows that have the same values into summary rows, like "find the number of customers in each country".
    The ``GROUP BY`` statement is often used with aggregate functions (``COUNT``, ``MAX``, ``MIN``, ``SUM``, ``AVG``) to group the result-set by one or more columns::

        SELECT <COLUMN_NAMES>
        FROM <TABLE_NAME>
        WHERE <CONDITION>
        GROUP BY <COLUMN_NAMES>
        ORDER BY <COLUMN_NAMES>;


* `HAVING`
    The `HAVING` clause was added to SQL because the WHERE keyword could not be used with aggregate functions::

        SELECT column_name(s)
        FROM table_name
        WHERE condition
        GROUP BY column_name(s)
        HAVING condition
        ORDER BY column_name(s);


* Operators

    - Bodo SQL currently supports the following arithmetic operators on columns:

        - ``+`` (Addition)
        - ``-`` (Subtraction)
        - ``*`` (Multiplication)

    - Bodo SQL currently supports the following comparision operators on columns:

        - ``=``	(Equal to)
        - ``>``	(Greater than)
        - ``<``	(Less than)
        - ``>=`` (Greater than or equal t)o
        - ``<=`` (Less than or equal to)
        - ``<>`` (Not equal to)

* Aliasing

    SQL aliases are used to give a table, or a column in a table, a temporary name::

        SELECT <COLUMN_NAME> AS <ALIAS>
        FROM <TABLE_NAME>;

    Aliases are often used to make column names more readable. An alias only exists for the duration of the query.
